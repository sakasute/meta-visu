/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/CategoryTimeline.js":
/*!*********************************!*\
  !*** ./src/CategoryTimeline.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass CategoryTimeline {\n  constructor(data, svgElement, config) {\n    this.config = {\n      width: config.width ? config.width : 400,\n      height: config.height ? config.height : 200,\n      posX: config.posX ? config.posX : 0,\n      posY: config.posY ? config.posY : 0,\n      scaleStartDate: config.scaleStartDate ? config.scaleStartDate : new Date('1970-01-01'),\n      scaleEndDate: config.scaleEndDate ? config.scaleEndDate : new Date(),\n      xAxisOrientation: config.xAxisOrientation ? config.xAxisOrientation : 'bottom',\n      showXAxis: config.showXAxis != null ? config.showXAxis : true,\n      showLegend: config.showLegend != null ? config.showLegend : true,\n    };\n    this.data = data;\n\n    this.xAxisPadding = 30;\n\n    this.svg = svgElement\n      .append('g')\n      .attr('class', 'timeline-chart')\n      .attr('width', this.config.width)\n      .attr('height', this.config.height + this.xAxisPadding)\n      .attr('transform', `translate(${this.config.posX}, ${this.config.posY})`);\n\n    this.x = d3\n      .scaleTime()\n      .domain([this.config.scaleStartDate, this.config.scaleEndDate])\n      .range([0, this.config.width - 25]);\n\n    this.y = d3\n      .scaleBand()\n      .domain(data.map(el => el.type))\n      .range([this.xAxisPadding, this.config.height])\n      .paddingInner(0.25)\n      .round(true);\n  }\n\n  static findEarliestStartDate(dataArr) {\n    return d3.min(dataArr, el => new Date(el.startDate));\n  }\n\n  static findLatestEndDate(dataArr) {\n    return d3.max(dataArr, el => new Date(el.endDate));\n  }\n\n  static createYearLabel(d) {\n    const startDate = new Date(d.startDate);\n    const endDate = new Date(d.endDate);\n    const startMonth = startDate.getMonth();\n    const endMonth = endDate.getMonth();\n    const startYear = startDate.getFullYear();\n    const endYear = endDate.getFullYear();\n\n    const startStr = startMonth === 0 ? startYear : `${startMonth + 1}/${startYear}`;\n    const endStr = endMonth === 11 ? endYear : `${endDate.getMonth() + 1}/${endYear}`;\n\n    if (startYear === endYear) {\n      if (startMonth === endMonth) {\n        return startStr;\n      } else if (startMonth === 0 && endMonth === 11) {\n        return startYear;\n      }\n    }\n\n    return `${startStr}—${endStr}`;\n  }\n\n  drawXAxis() {\n    let xAxis;\n    if (this.config.xAxisOrientation === 'top') {\n      xAxis = d3.axisTop(this.x);\n    } else {\n      xAxis = d3.axisBottom(this.x);\n    }\n\n    xAxis.ticks(d3.timeYear.every(10));\n\n    this.svg\n      .append('g')\n      .attr('class', 'timeline__axis')\n      .call(xAxis)\n      .attr('transform', () => {\n        if (this.config.xAxisOrientation === 'top') {\n          return 'translate(0, -2.5)';\n        }\n        return `translate(0, ${this.config.height - this.xAxisPadding + 2.5})`;\n      });\n  }\n\n  // FIXME: quite a clumsy way of doing this\n  drawLegend() {\n    const legend = this.svg.append('g').attr('class', 'legend');\n    legend.attr('transform', `translate(${this.config.width - 15}, 0)`);\n\n    const category1 = legend.append('g').attr('class', 'legend__category');\n\n    category1\n      .append('rect')\n      .attr('class', 'legend__color-1')\n      .attr('width', this.y.bandwidth() / 2)\n      .attr('height', this.y.bandwidth() / 2);\n\n    category1\n      .append('text')\n      .attr('class', 'legend__label')\n      .text('1987')\n      .attr('transform', `translate(${this.y.bandwidth() / 2 + 5}, ${this.y.bandwidth() / 2 - 5})`);\n\n    const category2 = legend.append('g').attr('class', 'legend__category');\n\n    category2\n      .append('rect')\n      .attr('class', 'legend__color-2')\n      .attr('width', this.y.bandwidth() / 2)\n      .attr('height', this.y.bandwidth() / 2)\n      .attr('transform', `translate(0, ${this.y.bandwidth() / 2})`);\n\n    category2\n      .append('text')\n      .attr('class', 'legend__label')\n      .text('1997')\n      .attr('transform', `translate(${this.y.bandwidth() / 2 + 5}, ${this.y.bandwidth() - 5})`);\n  }\n\n  calculateSectionWidth(sectionData) {\n    return this.x(new Date(sectionData.endDate)) - this.x(new Date(sectionData.startDate));\n  }\n\n  calculateSectionXPos(sectionData) {\n    return this.x(new Date(sectionData.startDate));\n  }\n\n  positionYearLabel(d) {\n    const xStart = this.x(new Date(d.startDate));\n    const xEnd = this.x(new Date(d.endDate));\n    const xCentre = (xStart + xEnd) / 2 - 2;\n\n    return `translate(${xCentre}, ${this.y.bandwidth() / 2 - 4})`;\n  }\n\n  moveTo(x, y) {\n    this.svg.attr('transform', `translate(${x}, ${y})`);\n  }\n\n  update() {\n    if (this.config.showXAxis) {\n      this.drawXAxis();\n    }\n\n    if (this.config.showLegend) {\n      this.drawLegend();\n    }\n    // enter\n    const categoryEnter = this.svg\n      .selectAll('.timeline')\n      .data(this.data)\n      .enter()\n      .append('g')\n      .attr('class', 'timeline');\n\n    categoryEnter.attr('transform', d => `translate(0, ${this.y(d.type) - this.xAxisPadding})`);\n\n    categoryEnter\n      .filter(d => d.type === 'parents')\n      .append('line')\n      .attr('class', 'timeline__separator')\n      .attr('x1', this.x(this.config.scaleStartDate) - 60)\n      .attr('y1', this.y.bandwidth() + 5)\n      .attr('x2', this.x(this.config.scaleEndDate))\n      .attr('y2', this.y.bandwidth() + 5);\n\n    categoryEnter\n      .append('text')\n      .attr('class', 'timeline__title')\n      .text(d => d.type)\n      .attr('dy', '1.5em')\n      .attr('dx', '-5em'); // FIXME: set text anchor correctly and change layout to position labels inside chart\n\n    const sectionEnter = categoryEnter\n      .selectAll('timeline__section')\n      .data(d => d.data)\n      .enter()\n      .append('g')\n      .attr('class', 'timeline__section');\n\n    // enter multiyear sections => rectangles\n    sectionEnter\n      .filter(d => new Date(d.startDate).getFullYear() !== new Date(d.endDate).getFullYear())\n      .append('rect')\n      .attr('class', 'timeline__rect')\n      .attr('x', d => this.calculateSectionXPos(d))\n      .attr('height', this.y.bandwidth() / 2)\n      .attr('width', d => this.calculateSectionWidth(d));\n\n    // enter 1 year sections => circles\n    sectionEnter\n      .filter(d => new Date(d.startDate).getFullYear() === new Date(d.endDate).getFullYear())\n      .append('circle')\n      .attr('r', this.y.bandwidth() / 4)\n      .attr('class', 'timeline__rect')\n      .attr('cx', d => this.calculateSectionXPos(d))\n      .attr('cy', 7.5);\n\n    // IDEA: if short timespans become a problem\n    // (ie. sections consisting of several small pieces leading to year labels overflowing),\n    // they could be combined before reaching this point\n    sectionEnter\n      .append('text')\n      .attr('class', 'timeline__year-label')\n      .text(d => this.constructor.createYearLabel(d))\n      .attr('text-anchor', 'middle')\n      .attr('transform', d => this.positionYearLabel(d));\n\n    sectionEnter\n      .filter(d => d.cohort === '1997')\n      .attr('transform', `translate(0, ${this.y.bandwidth() / 2})`)\n      .select('.timeline__rect')\n      .attr('class', 'timeline__rect timeline__rect--97');\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CategoryTimeline);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ2F0ZWdvcnlUaW1lbGluZS5qcz9iODEyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQixJQUFJLGlCQUFpQjs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsZUFBZSxHQUFHLFVBQVU7QUFDbkYsa0RBQWtELHVCQUF1QixHQUFHLFFBQVE7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxTQUFTLEdBQUcsT0FBTztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkNBQTZDO0FBQzVFLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUJBQXVCOztBQUVqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDJCQUEyQixJQUFJLDJCQUEyQjs7QUFFaEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx1QkFBdUI7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDJCQUEyQixJQUFJLHVCQUF1QjtBQUM1Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixRQUFRLElBQUksMkJBQTJCO0FBQy9EOztBQUVBO0FBQ0EsNENBQTRDLEVBQUUsSUFBSSxFQUFFO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUF5RCxtQ0FBbUM7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5Qyx1QkFBdUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9zcmMvQ2F0ZWdvcnlUaW1lbGluZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNsYXNzIENhdGVnb3J5VGltZWxpbmUge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBzdmdFbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIHdpZHRoOiBjb25maWcud2lkdGggPyBjb25maWcud2lkdGggOiA0MDAsXG4gICAgICBoZWlnaHQ6IGNvbmZpZy5oZWlnaHQgPyBjb25maWcuaGVpZ2h0IDogMjAwLFxuICAgICAgcG9zWDogY29uZmlnLnBvc1ggPyBjb25maWcucG9zWCA6IDAsXG4gICAgICBwb3NZOiBjb25maWcucG9zWSA/IGNvbmZpZy5wb3NZIDogMCxcbiAgICAgIHNjYWxlU3RhcnREYXRlOiBjb25maWcuc2NhbGVTdGFydERhdGUgPyBjb25maWcuc2NhbGVTdGFydERhdGUgOiBuZXcgRGF0ZSgnMTk3MC0wMS0wMScpLFxuICAgICAgc2NhbGVFbmREYXRlOiBjb25maWcuc2NhbGVFbmREYXRlID8gY29uZmlnLnNjYWxlRW5kRGF0ZSA6IG5ldyBEYXRlKCksXG4gICAgICB4QXhpc09yaWVudGF0aW9uOiBjb25maWcueEF4aXNPcmllbnRhdGlvbiA/IGNvbmZpZy54QXhpc09yaWVudGF0aW9uIDogJ2JvdHRvbScsXG4gICAgICBzaG93WEF4aXM6IGNvbmZpZy5zaG93WEF4aXMgIT0gbnVsbCA/IGNvbmZpZy5zaG93WEF4aXMgOiB0cnVlLFxuICAgICAgc2hvd0xlZ2VuZDogY29uZmlnLnNob3dMZWdlbmQgIT0gbnVsbCA/IGNvbmZpZy5zaG93TGVnZW5kIDogdHJ1ZSxcbiAgICB9O1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICB0aGlzLnhBeGlzUGFkZGluZyA9IDMwO1xuXG4gICAgdGhpcy5zdmcgPSBzdmdFbGVtZW50XG4gICAgICAuYXBwZW5kKCdnJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICd0aW1lbGluZS1jaGFydCcpXG4gICAgICAuYXR0cignd2lkdGgnLCB0aGlzLmNvbmZpZy53aWR0aClcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmNvbmZpZy5oZWlnaHQgKyB0aGlzLnhBeGlzUGFkZGluZylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5jb25maWcucG9zWH0sICR7dGhpcy5jb25maWcucG9zWX0pYCk7XG5cbiAgICB0aGlzLnggPSBkM1xuICAgICAgLnNjYWxlVGltZSgpXG4gICAgICAuZG9tYWluKFt0aGlzLmNvbmZpZy5zY2FsZVN0YXJ0RGF0ZSwgdGhpcy5jb25maWcuc2NhbGVFbmREYXRlXSlcbiAgICAgIC5yYW5nZShbMCwgdGhpcy5jb25maWcud2lkdGggLSAyNV0pO1xuXG4gICAgdGhpcy55ID0gZDNcbiAgICAgIC5zY2FsZUJhbmQoKVxuICAgICAgLmRvbWFpbihkYXRhLm1hcChlbCA9PiBlbC50eXBlKSlcbiAgICAgIC5yYW5nZShbdGhpcy54QXhpc1BhZGRpbmcsIHRoaXMuY29uZmlnLmhlaWdodF0pXG4gICAgICAucGFkZGluZ0lubmVyKDAuMjUpXG4gICAgICAucm91bmQodHJ1ZSk7XG4gIH1cblxuICBzdGF0aWMgZmluZEVhcmxpZXN0U3RhcnREYXRlKGRhdGFBcnIpIHtcbiAgICByZXR1cm4gZDMubWluKGRhdGFBcnIsIGVsID0+IG5ldyBEYXRlKGVsLnN0YXJ0RGF0ZSkpO1xuICB9XG5cbiAgc3RhdGljIGZpbmRMYXRlc3RFbmREYXRlKGRhdGFBcnIpIHtcbiAgICByZXR1cm4gZDMubWF4KGRhdGFBcnIsIGVsID0+IG5ldyBEYXRlKGVsLmVuZERhdGUpKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVZZWFyTGFiZWwoZCkge1xuICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKGQuc3RhcnREYXRlKTtcbiAgICBjb25zdCBlbmREYXRlID0gbmV3IERhdGUoZC5lbmREYXRlKTtcbiAgICBjb25zdCBzdGFydE1vbnRoID0gc3RhcnREYXRlLmdldE1vbnRoKCk7XG4gICAgY29uc3QgZW5kTW9udGggPSBlbmREYXRlLmdldE1vbnRoKCk7XG4gICAgY29uc3Qgc3RhcnRZZWFyID0gc3RhcnREYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgY29uc3QgZW5kWWVhciA9IGVuZERhdGUuZ2V0RnVsbFllYXIoKTtcblxuICAgIGNvbnN0IHN0YXJ0U3RyID0gc3RhcnRNb250aCA9PT0gMCA/IHN0YXJ0WWVhciA6IGAke3N0YXJ0TW9udGggKyAxfS8ke3N0YXJ0WWVhcn1gO1xuICAgIGNvbnN0IGVuZFN0ciA9IGVuZE1vbnRoID09PSAxMSA/IGVuZFllYXIgOiBgJHtlbmREYXRlLmdldE1vbnRoKCkgKyAxfS8ke2VuZFllYXJ9YDtcblxuICAgIGlmIChzdGFydFllYXIgPT09IGVuZFllYXIpIHtcbiAgICAgIGlmIChzdGFydE1vbnRoID09PSBlbmRNb250aCkge1xuICAgICAgICByZXR1cm4gc3RhcnRTdHI7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0TW9udGggPT09IDAgJiYgZW5kTW9udGggPT09IDExKSB7XG4gICAgICAgIHJldHVybiBzdGFydFllYXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3N0YXJ0U3RyfeKAlCR7ZW5kU3RyfWA7XG4gIH1cblxuICBkcmF3WEF4aXMoKSB7XG4gICAgbGV0IHhBeGlzO1xuICAgIGlmICh0aGlzLmNvbmZpZy54QXhpc09yaWVudGF0aW9uID09PSAndG9wJykge1xuICAgICAgeEF4aXMgPSBkMy5heGlzVG9wKHRoaXMueCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHhBeGlzID0gZDMuYXhpc0JvdHRvbSh0aGlzLngpO1xuICAgIH1cblxuICAgIHhBeGlzLnRpY2tzKGQzLnRpbWVZZWFyLmV2ZXJ5KDEwKSk7XG5cbiAgICB0aGlzLnN2Z1xuICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAuYXR0cignY2xhc3MnLCAndGltZWxpbmVfX2F4aXMnKVxuICAgICAgLmNhbGwoeEF4aXMpXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb25maWcueEF4aXNPcmllbnRhdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwLCAtMi41KSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoMCwgJHt0aGlzLmNvbmZpZy5oZWlnaHQgLSB0aGlzLnhBeGlzUGFkZGluZyArIDIuNX0pYDtcbiAgICAgIH0pO1xuICB9XG5cbiAgLy8gRklYTUU6IHF1aXRlIGEgY2x1bXN5IHdheSBvZiBkb2luZyB0aGlzXG4gIGRyYXdMZWdlbmQoKSB7XG4gICAgY29uc3QgbGVnZW5kID0gdGhpcy5zdmcuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbGVnZW5kJyk7XG4gICAgbGVnZW5kLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLmNvbmZpZy53aWR0aCAtIDE1fSwgMClgKTtcblxuICAgIGNvbnN0IGNhdGVnb3J5MSA9IGxlZ2VuZC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdsZWdlbmRfX2NhdGVnb3J5Jyk7XG5cbiAgICBjYXRlZ29yeTFcbiAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZ2VuZF9fY29sb3ItMScpXG4gICAgICAuYXR0cignd2lkdGgnLCB0aGlzLnkuYmFuZHdpZHRoKCkgLyAyKVxuICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMueS5iYW5kd2lkdGgoKSAvIDIpO1xuXG4gICAgY2F0ZWdvcnkxXG4gICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdsZWdlbmRfX2xhYmVsJylcbiAgICAgIC50ZXh0KCcxOTg3JylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy55LmJhbmR3aWR0aCgpIC8gMiArIDV9LCAke3RoaXMueS5iYW5kd2lkdGgoKSAvIDIgLSA1fSlgKTtcblxuICAgIGNvbnN0IGNhdGVnb3J5MiA9IGxlZ2VuZC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdsZWdlbmRfX2NhdGVnb3J5Jyk7XG5cbiAgICBjYXRlZ29yeTJcbiAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZ2VuZF9fY29sb3ItMicpXG4gICAgICAuYXR0cignd2lkdGgnLCB0aGlzLnkuYmFuZHdpZHRoKCkgLyAyKVxuICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMueS5iYW5kd2lkdGgoKSAvIDIpXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAke3RoaXMueS5iYW5kd2lkdGgoKSAvIDJ9KWApO1xuXG4gICAgY2F0ZWdvcnkyXG4gICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdsZWdlbmRfX2xhYmVsJylcbiAgICAgIC50ZXh0KCcxOTk3JylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy55LmJhbmR3aWR0aCgpIC8gMiArIDV9LCAke3RoaXMueS5iYW5kd2lkdGgoKSAtIDV9KWApO1xuICB9XG5cbiAgY2FsY3VsYXRlU2VjdGlvbldpZHRoKHNlY3Rpb25EYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMueChuZXcgRGF0ZShzZWN0aW9uRGF0YS5lbmREYXRlKSkgLSB0aGlzLngobmV3IERhdGUoc2VjdGlvbkRhdGEuc3RhcnREYXRlKSk7XG4gIH1cblxuICBjYWxjdWxhdGVTZWN0aW9uWFBvcyhzZWN0aW9uRGF0YSkge1xuICAgIHJldHVybiB0aGlzLngobmV3IERhdGUoc2VjdGlvbkRhdGEuc3RhcnREYXRlKSk7XG4gIH1cblxuICBwb3NpdGlvblllYXJMYWJlbChkKSB7XG4gICAgY29uc3QgeFN0YXJ0ID0gdGhpcy54KG5ldyBEYXRlKGQuc3RhcnREYXRlKSk7XG4gICAgY29uc3QgeEVuZCA9IHRoaXMueChuZXcgRGF0ZShkLmVuZERhdGUpKTtcbiAgICBjb25zdCB4Q2VudHJlID0gKHhTdGFydCArIHhFbmQpIC8gMiAtIDI7XG5cbiAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3hDZW50cmV9LCAke3RoaXMueS5iYW5kd2lkdGgoKSAvIDIgLSA0fSlgO1xuICB9XG5cbiAgbW92ZVRvKHgsIHkpIHtcbiAgICB0aGlzLnN2Zy5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sICR7eX0pYCk7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLnNob3dYQXhpcykge1xuICAgICAgdGhpcy5kcmF3WEF4aXMoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25maWcuc2hvd0xlZ2VuZCkge1xuICAgICAgdGhpcy5kcmF3TGVnZW5kKCk7XG4gICAgfVxuICAgIC8vIGVudGVyXG4gICAgY29uc3QgY2F0ZWdvcnlFbnRlciA9IHRoaXMuc3ZnXG4gICAgICAuc2VsZWN0QWxsKCcudGltZWxpbmUnKVxuICAgICAgLmRhdGEodGhpcy5kYXRhKVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoJ2cnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ3RpbWVsaW5lJyk7XG5cbiAgICBjYXRlZ29yeUVudGVyLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gYHRyYW5zbGF0ZSgwLCAke3RoaXMueShkLnR5cGUpIC0gdGhpcy54QXhpc1BhZGRpbmd9KWApO1xuXG4gICAgY2F0ZWdvcnlFbnRlclxuICAgICAgLmZpbHRlcihkID0+IGQudHlwZSA9PT0gJ3BhcmVudHMnKVxuICAgICAgLmFwcGVuZCgnbGluZScpXG4gICAgICAuYXR0cignY2xhc3MnLCAndGltZWxpbmVfX3NlcGFyYXRvcicpXG4gICAgICAuYXR0cigneDEnLCB0aGlzLngodGhpcy5jb25maWcuc2NhbGVTdGFydERhdGUpIC0gNjApXG4gICAgICAuYXR0cigneTEnLCB0aGlzLnkuYmFuZHdpZHRoKCkgKyA1KVxuICAgICAgLmF0dHIoJ3gyJywgdGhpcy54KHRoaXMuY29uZmlnLnNjYWxlRW5kRGF0ZSkpXG4gICAgICAuYXR0cigneTInLCB0aGlzLnkuYmFuZHdpZHRoKCkgKyA1KTtcblxuICAgIGNhdGVnb3J5RW50ZXJcbiAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ3RpbWVsaW5lX190aXRsZScpXG4gICAgICAudGV4dChkID0+IGQudHlwZSlcbiAgICAgIC5hdHRyKCdkeScsICcxLjVlbScpXG4gICAgICAuYXR0cignZHgnLCAnLTVlbScpOyAvLyBGSVhNRTogc2V0IHRleHQgYW5jaG9yIGNvcnJlY3RseSBhbmQgY2hhbmdlIGxheW91dCB0byBwb3NpdGlvbiBsYWJlbHMgaW5zaWRlIGNoYXJ0XG5cbiAgICBjb25zdCBzZWN0aW9uRW50ZXIgPSBjYXRlZ29yeUVudGVyXG4gICAgICAuc2VsZWN0QWxsKCd0aW1lbGluZV9fc2VjdGlvbicpXG4gICAgICAuZGF0YShkID0+IGQuZGF0YSlcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdnJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICd0aW1lbGluZV9fc2VjdGlvbicpO1xuXG4gICAgLy8gZW50ZXIgbXVsdGl5ZWFyIHNlY3Rpb25zID0+IHJlY3RhbmdsZXNcbiAgICBzZWN0aW9uRW50ZXJcbiAgICAgIC5maWx0ZXIoZCA9PiBuZXcgRGF0ZShkLnN0YXJ0RGF0ZSkuZ2V0RnVsbFllYXIoKSAhPT0gbmV3IERhdGUoZC5lbmREYXRlKS5nZXRGdWxsWWVhcigpKVxuICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAuYXR0cignY2xhc3MnLCAndGltZWxpbmVfX3JlY3QnKVxuICAgICAgLmF0dHIoJ3gnLCBkID0+IHRoaXMuY2FsY3VsYXRlU2VjdGlvblhQb3MoZCkpXG4gICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy55LmJhbmR3aWR0aCgpIC8gMilcbiAgICAgIC5hdHRyKCd3aWR0aCcsIGQgPT4gdGhpcy5jYWxjdWxhdGVTZWN0aW9uV2lkdGgoZCkpO1xuXG4gICAgLy8gZW50ZXIgMSB5ZWFyIHNlY3Rpb25zID0+IGNpcmNsZXNcbiAgICBzZWN0aW9uRW50ZXJcbiAgICAgIC5maWx0ZXIoZCA9PiBuZXcgRGF0ZShkLnN0YXJ0RGF0ZSkuZ2V0RnVsbFllYXIoKSA9PT0gbmV3IERhdGUoZC5lbmREYXRlKS5nZXRGdWxsWWVhcigpKVxuICAgICAgLmFwcGVuZCgnY2lyY2xlJylcbiAgICAgIC5hdHRyKCdyJywgdGhpcy55LmJhbmR3aWR0aCgpIC8gNClcbiAgICAgIC5hdHRyKCdjbGFzcycsICd0aW1lbGluZV9fcmVjdCcpXG4gICAgICAuYXR0cignY3gnLCBkID0+IHRoaXMuY2FsY3VsYXRlU2VjdGlvblhQb3MoZCkpXG4gICAgICAuYXR0cignY3knLCA3LjUpO1xuXG4gICAgLy8gSURFQTogaWYgc2hvcnQgdGltZXNwYW5zIGJlY29tZSBhIHByb2JsZW1cbiAgICAvLyAoaWUuIHNlY3Rpb25zIGNvbnNpc3Rpbmcgb2Ygc2V2ZXJhbCBzbWFsbCBwaWVjZXMgbGVhZGluZyB0byB5ZWFyIGxhYmVscyBvdmVyZmxvd2luZyksXG4gICAgLy8gdGhleSBjb3VsZCBiZSBjb21iaW5lZCBiZWZvcmUgcmVhY2hpbmcgdGhpcyBwb2ludFxuICAgIHNlY3Rpb25FbnRlclxuICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAuYXR0cignY2xhc3MnLCAndGltZWxpbmVfX3llYXItbGFiZWwnKVxuICAgICAgLnRleHQoZCA9PiB0aGlzLmNvbnN0cnVjdG9yLmNyZWF0ZVllYXJMYWJlbChkKSlcbiAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gdGhpcy5wb3NpdGlvblllYXJMYWJlbChkKSk7XG5cbiAgICBzZWN0aW9uRW50ZXJcbiAgICAgIC5maWx0ZXIoZCA9PiBkLmNvaG9ydCA9PT0gJzE5OTcnKVxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwgJHt0aGlzLnkuYmFuZHdpZHRoKCkgLyAyfSlgKVxuICAgICAgLnNlbGVjdCgnLnRpbWVsaW5lX19yZWN0JylcbiAgICAgIC5hdHRyKCdjbGFzcycsICd0aW1lbGluZV9fcmVjdCB0aW1lbGluZV9fcmVjdC0tOTcnKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXRlZ29yeVRpbWVsaW5lO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/CategoryTimeline.js\n");

/***/ }),

/***/ "./src/TreeChart.js":
/*!**************************!*\
  !*** ./src/TreeChart.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass TreeChart {\n  constructor(data, svgElement, config) {\n    this.config = {\n      width: config.width ? config.width : 400,\n      height: config.height ? config.height : 200,\n      posX: config.posX ? config.posX : 0,\n      posY: config.posY ? config.posY : 0,\n      childrenNames: config.childrenNames\n        ? config.childrenNames\n        : ['registerAdmins', 'registers', 'categories', 'samplings'],\n      nodeSize: config.nodeSize ? config.nodeSize : 10,\n      animationDuration: config.animationDuration ? config.animationDuration : 750,\n    };\n    const treeHeight = this.config.height;\n    const treeWidth = this.config.width;\n    const treeLayout = d3\n      .tree()\n      .size([treeHeight, treeWidth])\n      .separation(() => 1); // NOTE: this seems to spread all the leaf nodes equally far apart\n\n    const hierarchy = d3.hierarchy(data, d => this.findChildArr(d));\n\n    this.treeData = treeLayout(hierarchy);\n\n    this.svg = svgElement\n      .append('g')\n      .attr('class', 'tree')\n      .attr('width', this.config.width)\n      .attr('height', this.config.height)\n      .attr('transform', `translate(${this.config.posX}, ${this.config.posY})`)\n      .append('g');\n\n    this.sourceCoord = { x: treeHeight / 2, y: 0 };\n    this.idCounter = 0;\n  }\n\n  static diagonal(s, d) {\n    const path = `M ${s.y} ${s.x}\n                  C ${(s.y + d.y) / 2} ${s.x},\n                    ${(s.y + d.y) / 2} ${d.x},\n                    ${d.y} ${d.x}`;\n\n    return path;\n  }\n\n  static calculateLabelPlacement(d) {\n    try {\n      if (Math.ceil(d.x) > Math.ceil(d.parent.x)) {\n        d.labelPosition = 'under';\n      } else if (Math.ceil(d.x) < Math.ceil(d.parent.x)) {\n        d.labelPosition = 'top';\n      } else {\n        d.labelPosition = d.parent.labelPosition ? d.parent.labelPosition : 'top';\n      }\n    } finally {\n      switch (d.labelPosition) {\n        case 'top':\n          return '-1em';\n        case 'under':\n          return '1.5em';\n        default:\n          return '0em';\n      }\n    }\n  }\n\n  findChildArr(object) {\n    const childArrNames = this.config.childrenNames;\n    const childrenName = childArrNames.filter(name => object[name] !== undefined)[0];\n    if (childrenName !== undefined) {\n      return object[childrenName];\n    }\n    return null;\n  }\n\n  drawNodeCircles(nodeGroup) {\n    nodeGroup\n      .append('circle')\n      .attr('class', 'tree__node-marker')\n      .attr('r', this.config.nodeSize);\n  }\n  /* eslint-disable class-methods-use-this */\n  moveNodesInPlace(nodeGroup) {\n    nodeGroup.attr('transform', d => `translate(${d.y}, ${d.x})`);\n  }\n\n  addNodeLabels(nodeGroup) {\n    nodeGroup\n      .filter(d => d.parent)\n      .append('text')\n      .attr('class', 'tree__node-label')\n      .attr('dy', d => this.constructor.calculateLabelPlacement(d))\n      .attr('x', -25)\n      .attr('text-anchor', 'middle')\n      // NOTE: limit the length of node labels (the difference between lengths in test)\n      // and slice is to prevent the \"...\" being lengthier than removed chars.\n      .text(d => (d.data.name.length <= 43 ? d.data.name : `${d.data.name.slice(0, 40)}...`))\n      .on('mouseover', (d, i, nodes) => this.showFullLabel(d, i, nodes))\n      .on('mouseout', (d, i, nodes) => this.showNormalLabel(d, i, nodes));\n\n    // NOTE: handle root node separately to support text wrapping\n    this.addRootLabel(nodeGroup.filter(d => !d.parent));\n  }\n\n  showFullLabel(dataNode, i, nodes) {\n    d3.select(nodes[i]).text(d => d.data.name);\n  }\n\n  showNormalLabel(data, i, nodes) {\n    d3.select(nodes[i]).text(d => (d.data.name.length <= 43 ? d.data.name : `${d.data.name.slice(0, 40)}...`));\n  }\n\n  addRootLabel(rootNode) {\n    const fo = rootNode.append('foreignObject').attr('class', 'tree__html-object');\n\n    const rootLabel = fo\n      .append('xhtml:p')\n      .attr('class', 'tree__html-label')\n      .html(d => d.data.name);\n\n    const boundingRect = rootLabel.node().getBoundingClientRect();\n    fo.attr('transform', `translate(${-1 * boundingRect.width}, ${boundingRect.height / -2})`);\n  }\n  /* eslint-enable class-methods-use-this */\n\n  updateNodes() {\n    const nodesData = this.treeData.descendants();\n    const nodeSelection = this.svg.selectAll('.node').data(nodesData, (d) => {\n      const id = d.id ? d.id : this.idCounter;\n      d.id = id;\n      this.idCounter += 1;\n      return id;\n    });\n\n    // enter\n    const nodeEnter = nodeSelection\n      .enter()\n      // .filter(d => d.depth > 0)\n      .append('g')\n      .attr('class', 'tree__node')\n      .attr('transform', () => `translate(${this.sourceCoord.y}, ${this.sourceCoord.x})`);\n    // .on('click', (d) => {\n    //   this.clickNode(d);\n    // });\n\n    // this.drawNodeCircles(nodeEnter.merge(nodeSelection));\n    this.moveNodesInPlace(nodeEnter);\n    this.addNodeLabels(nodeEnter);\n\n    // exit\n    nodeSelection\n      .exit()\n      // .transition()\n      // .duration(this.config.animationDuration)\n      .attr('transform', `translate(${this.sourceCoord.y}, ${this.sourceCoord.x})`)\n      .remove();\n  }\n\n  updateLinks() {\n    const linksData = this.treeData.descendants().slice(1);\n    const linkSelection = this.svg.selectAll('path.link').data(linksData, (d) => {\n      const id = d.id ? d.id : this.idCounter;\n      d.id = id;\n      this.idCounter += 1;\n      return id;\n    });\n\n    // enter\n    const linkEnter = linkSelection\n      .enter()\n      // .filter(d => d.depth > 1) // don't draw links to root element\n      .insert('path', 'g')\n      .attr('class', 'tree__link')\n      .attr('d', () => {\n        const o = { x: this.sourceCoord.x, y: this.sourceCoord.y };\n        return this.constructor.diagonal(o, o);\n      });\n\n    linkEnter\n      // .transition()\n      // .duration(this.config.duration)\n      .attr('d', d => this.constructor.diagonal(d, d.parent));\n\n    // exit\n    linkSelection\n      .exit()\n      .transition()\n      .duration(750)\n      .attr('d', () => {\n        const o = { y: this.sourceCoord.y, x: this.sourceCoord.x };\n        return this.constructor.diagonal(o, o);\n      })\n      .remove();\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (TreeChart);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVHJlZUNoYXJ0LmpzPzc5OGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCLElBQUksaUJBQWlCO0FBQzVFOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLElBQUksR0FBRztBQUM3QixzQkFBc0IsZ0JBQWdCLEdBQUcsSUFBSTtBQUM3QyxzQkFBc0IsZ0JBQWdCLEdBQUcsSUFBSTtBQUM3QyxzQkFBc0IsSUFBSSxHQUFHLElBQUk7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSSxJQUFJLElBQUk7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQseUJBQXlCO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtFQUErRSx5QkFBeUI7QUFDeEc7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyx3QkFBd0IsSUFBSSx5QkFBeUI7QUFDM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1CQUFtQixJQUFJLG1CQUFtQjtBQUN0RjtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtQkFBbUIsSUFBSSxtQkFBbUI7QUFDaEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9zcmMvVHJlZUNoYXJ0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgVHJlZUNoYXJ0IHtcbiAgY29uc3RydWN0b3IoZGF0YSwgc3ZnRWxlbWVudCwgY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICB3aWR0aDogY29uZmlnLndpZHRoID8gY29uZmlnLndpZHRoIDogNDAwLFxuICAgICAgaGVpZ2h0OiBjb25maWcuaGVpZ2h0ID8gY29uZmlnLmhlaWdodCA6IDIwMCxcbiAgICAgIHBvc1g6IGNvbmZpZy5wb3NYID8gY29uZmlnLnBvc1ggOiAwLFxuICAgICAgcG9zWTogY29uZmlnLnBvc1kgPyBjb25maWcucG9zWSA6IDAsXG4gICAgICBjaGlsZHJlbk5hbWVzOiBjb25maWcuY2hpbGRyZW5OYW1lc1xuICAgICAgICA/IGNvbmZpZy5jaGlsZHJlbk5hbWVzXG4gICAgICAgIDogWydyZWdpc3RlckFkbWlucycsICdyZWdpc3RlcnMnLCAnY2F0ZWdvcmllcycsICdzYW1wbGluZ3MnXSxcbiAgICAgIG5vZGVTaXplOiBjb25maWcubm9kZVNpemUgPyBjb25maWcubm9kZVNpemUgOiAxMCxcbiAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiBjb25maWcuYW5pbWF0aW9uRHVyYXRpb24gPyBjb25maWcuYW5pbWF0aW9uRHVyYXRpb24gOiA3NTAsXG4gICAgfTtcbiAgICBjb25zdCB0cmVlSGVpZ2h0ID0gdGhpcy5jb25maWcuaGVpZ2h0O1xuICAgIGNvbnN0IHRyZWVXaWR0aCA9IHRoaXMuY29uZmlnLndpZHRoO1xuICAgIGNvbnN0IHRyZWVMYXlvdXQgPSBkM1xuICAgICAgLnRyZWUoKVxuICAgICAgLnNpemUoW3RyZWVIZWlnaHQsIHRyZWVXaWR0aF0pXG4gICAgICAuc2VwYXJhdGlvbigoKSA9PiAxKTsgLy8gTk9URTogdGhpcyBzZWVtcyB0byBzcHJlYWQgYWxsIHRoZSBsZWFmIG5vZGVzIGVxdWFsbHkgZmFyIGFwYXJ0XG5cbiAgICBjb25zdCBoaWVyYXJjaHkgPSBkMy5oaWVyYXJjaHkoZGF0YSwgZCA9PiB0aGlzLmZpbmRDaGlsZEFycihkKSk7XG5cbiAgICB0aGlzLnRyZWVEYXRhID0gdHJlZUxheW91dChoaWVyYXJjaHkpO1xuXG4gICAgdGhpcy5zdmcgPSBzdmdFbGVtZW50XG4gICAgICAuYXBwZW5kKCdnJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICd0cmVlJylcbiAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMuY29uZmlnLndpZHRoKVxuICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuY29uZmlnLmhlaWdodClcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5jb25maWcucG9zWH0sICR7dGhpcy5jb25maWcucG9zWX0pYClcbiAgICAgIC5hcHBlbmQoJ2cnKTtcblxuICAgIHRoaXMuc291cmNlQ29vcmQgPSB7IHg6IHRyZWVIZWlnaHQgLyAyLCB5OiAwIH07XG4gICAgdGhpcy5pZENvdW50ZXIgPSAwO1xuICB9XG5cbiAgc3RhdGljIGRpYWdvbmFsKHMsIGQpIHtcbiAgICBjb25zdCBwYXRoID0gYE0gJHtzLnl9ICR7cy54fVxuICAgICAgICAgICAgICAgICAgQyAkeyhzLnkgKyBkLnkpIC8gMn0gJHtzLnh9LFxuICAgICAgICAgICAgICAgICAgICAkeyhzLnkgKyBkLnkpIC8gMn0gJHtkLnh9LFxuICAgICAgICAgICAgICAgICAgICAke2QueX0gJHtkLnh9YDtcblxuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgc3RhdGljIGNhbGN1bGF0ZUxhYmVsUGxhY2VtZW50KGQpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKE1hdGguY2VpbChkLngpID4gTWF0aC5jZWlsKGQucGFyZW50LngpKSB7XG4gICAgICAgIGQubGFiZWxQb3NpdGlvbiA9ICd1bmRlcic7XG4gICAgICB9IGVsc2UgaWYgKE1hdGguY2VpbChkLngpIDwgTWF0aC5jZWlsKGQucGFyZW50LngpKSB7XG4gICAgICAgIGQubGFiZWxQb3NpdGlvbiA9ICd0b3AnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZC5sYWJlbFBvc2l0aW9uID0gZC5wYXJlbnQubGFiZWxQb3NpdGlvbiA/IGQucGFyZW50LmxhYmVsUG9zaXRpb24gOiAndG9wJztcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgc3dpdGNoIChkLmxhYmVsUG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICByZXR1cm4gJy0xZW0nO1xuICAgICAgICBjYXNlICd1bmRlcic6XG4gICAgICAgICAgcmV0dXJuICcxLjVlbSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICcwZW0nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZpbmRDaGlsZEFycihvYmplY3QpIHtcbiAgICBjb25zdCBjaGlsZEFyck5hbWVzID0gdGhpcy5jb25maWcuY2hpbGRyZW5OYW1lcztcbiAgICBjb25zdCBjaGlsZHJlbk5hbWUgPSBjaGlsZEFyck5hbWVzLmZpbHRlcihuYW1lID0+IG9iamVjdFtuYW1lXSAhPT0gdW5kZWZpbmVkKVswXTtcbiAgICBpZiAoY2hpbGRyZW5OYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBvYmplY3RbY2hpbGRyZW5OYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkcmF3Tm9kZUNpcmNsZXMobm9kZUdyb3VwKSB7XG4gICAgbm9kZUdyb3VwXG4gICAgICAuYXBwZW5kKCdjaXJjbGUnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ3RyZWVfX25vZGUtbWFya2VyJylcbiAgICAgIC5hdHRyKCdyJywgdGhpcy5jb25maWcubm9kZVNpemUpO1xuICB9XG4gIC8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbiAgbW92ZU5vZGVzSW5QbGFjZShub2RlR3JvdXApIHtcbiAgICBub2RlR3JvdXAuYXR0cigndHJhbnNmb3JtJywgZCA9PiBgdHJhbnNsYXRlKCR7ZC55fSwgJHtkLnh9KWApO1xuICB9XG5cbiAgYWRkTm9kZUxhYmVscyhub2RlR3JvdXApIHtcbiAgICBub2RlR3JvdXBcbiAgICAgIC5maWx0ZXIoZCA9PiBkLnBhcmVudClcbiAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ3RyZWVfX25vZGUtbGFiZWwnKVxuICAgICAgLmF0dHIoJ2R5JywgZCA9PiB0aGlzLmNvbnN0cnVjdG9yLmNhbGN1bGF0ZUxhYmVsUGxhY2VtZW50KGQpKVxuICAgICAgLmF0dHIoJ3gnLCAtMjUpXG4gICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcbiAgICAgIC8vIE5PVEU6IGxpbWl0IHRoZSBsZW5ndGggb2Ygbm9kZSBsYWJlbHMgKHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gbGVuZ3RocyBpbiB0ZXN0KVxuICAgICAgLy8gYW5kIHNsaWNlIGlzIHRvIHByZXZlbnQgdGhlIFwiLi4uXCIgYmVpbmcgbGVuZ3RoaWVyIHRoYW4gcmVtb3ZlZCBjaGFycy5cbiAgICAgIC50ZXh0KGQgPT4gKGQuZGF0YS5uYW1lLmxlbmd0aCA8PSA0MyA/IGQuZGF0YS5uYW1lIDogYCR7ZC5kYXRhLm5hbWUuc2xpY2UoMCwgNDApfS4uLmApKVxuICAgICAgLm9uKCdtb3VzZW92ZXInLCAoZCwgaSwgbm9kZXMpID0+IHRoaXMuc2hvd0Z1bGxMYWJlbChkLCBpLCBub2RlcykpXG4gICAgICAub24oJ21vdXNlb3V0JywgKGQsIGksIG5vZGVzKSA9PiB0aGlzLnNob3dOb3JtYWxMYWJlbChkLCBpLCBub2RlcykpO1xuXG4gICAgLy8gTk9URTogaGFuZGxlIHJvb3Qgbm9kZSBzZXBhcmF0ZWx5IHRvIHN1cHBvcnQgdGV4dCB3cmFwcGluZ1xuICAgIHRoaXMuYWRkUm9vdExhYmVsKG5vZGVHcm91cC5maWx0ZXIoZCA9PiAhZC5wYXJlbnQpKTtcbiAgfVxuXG4gIHNob3dGdWxsTGFiZWwoZGF0YU5vZGUsIGksIG5vZGVzKSB7XG4gICAgZDMuc2VsZWN0KG5vZGVzW2ldKS50ZXh0KGQgPT4gZC5kYXRhLm5hbWUpO1xuICB9XG5cbiAgc2hvd05vcm1hbExhYmVsKGRhdGEsIGksIG5vZGVzKSB7XG4gICAgZDMuc2VsZWN0KG5vZGVzW2ldKS50ZXh0KGQgPT4gKGQuZGF0YS5uYW1lLmxlbmd0aCA8PSA0MyA/IGQuZGF0YS5uYW1lIDogYCR7ZC5kYXRhLm5hbWUuc2xpY2UoMCwgNDApfS4uLmApKTtcbiAgfVxuXG4gIGFkZFJvb3RMYWJlbChyb290Tm9kZSkge1xuICAgIGNvbnN0IGZvID0gcm9vdE5vZGUuYXBwZW5kKCdmb3JlaWduT2JqZWN0JykuYXR0cignY2xhc3MnLCAndHJlZV9faHRtbC1vYmplY3QnKTtcblxuICAgIGNvbnN0IHJvb3RMYWJlbCA9IGZvXG4gICAgICAuYXBwZW5kKCd4aHRtbDpwJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICd0cmVlX19odG1sLWxhYmVsJylcbiAgICAgIC5odG1sKGQgPT4gZC5kYXRhLm5hbWUpO1xuXG4gICAgY29uc3QgYm91bmRpbmdSZWN0ID0gcm9vdExhYmVsLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBmby5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7LTEgKiBib3VuZGluZ1JlY3Qud2lkdGh9LCAke2JvdW5kaW5nUmVjdC5oZWlnaHQgLyAtMn0pYCk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG5cbiAgdXBkYXRlTm9kZXMoKSB7XG4gICAgY29uc3Qgbm9kZXNEYXRhID0gdGhpcy50cmVlRGF0YS5kZXNjZW5kYW50cygpO1xuICAgIGNvbnN0IG5vZGVTZWxlY3Rpb24gPSB0aGlzLnN2Zy5zZWxlY3RBbGwoJy5ub2RlJykuZGF0YShub2Rlc0RhdGEsIChkKSA9PiB7XG4gICAgICBjb25zdCBpZCA9IGQuaWQgPyBkLmlkIDogdGhpcy5pZENvdW50ZXI7XG4gICAgICBkLmlkID0gaWQ7XG4gICAgICB0aGlzLmlkQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0pO1xuXG4gICAgLy8gZW50ZXJcbiAgICBjb25zdCBub2RlRW50ZXIgPSBub2RlU2VsZWN0aW9uXG4gICAgICAuZW50ZXIoKVxuICAgICAgLy8gLmZpbHRlcihkID0+IGQuZGVwdGggPiAwKVxuICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAuYXR0cignY2xhc3MnLCAndHJlZV9fbm9kZScpXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgKCkgPT4gYHRyYW5zbGF0ZSgke3RoaXMuc291cmNlQ29vcmQueX0sICR7dGhpcy5zb3VyY2VDb29yZC54fSlgKTtcbiAgICAvLyAub24oJ2NsaWNrJywgKGQpID0+IHtcbiAgICAvLyAgIHRoaXMuY2xpY2tOb2RlKGQpO1xuICAgIC8vIH0pO1xuXG4gICAgLy8gdGhpcy5kcmF3Tm9kZUNpcmNsZXMobm9kZUVudGVyLm1lcmdlKG5vZGVTZWxlY3Rpb24pKTtcbiAgICB0aGlzLm1vdmVOb2Rlc0luUGxhY2Uobm9kZUVudGVyKTtcbiAgICB0aGlzLmFkZE5vZGVMYWJlbHMobm9kZUVudGVyKTtcblxuICAgIC8vIGV4aXRcbiAgICBub2RlU2VsZWN0aW9uXG4gICAgICAuZXhpdCgpXG4gICAgICAvLyAudHJhbnNpdGlvbigpXG4gICAgICAvLyAuZHVyYXRpb24odGhpcy5jb25maWcuYW5pbWF0aW9uRHVyYXRpb24pXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMuc291cmNlQ29vcmQueX0sICR7dGhpcy5zb3VyY2VDb29yZC54fSlgKVxuICAgICAgLnJlbW92ZSgpO1xuICB9XG5cbiAgdXBkYXRlTGlua3MoKSB7XG4gICAgY29uc3QgbGlua3NEYXRhID0gdGhpcy50cmVlRGF0YS5kZXNjZW5kYW50cygpLnNsaWNlKDEpO1xuICAgIGNvbnN0IGxpbmtTZWxlY3Rpb24gPSB0aGlzLnN2Zy5zZWxlY3RBbGwoJ3BhdGgubGluaycpLmRhdGEobGlua3NEYXRhLCAoZCkgPT4ge1xuICAgICAgY29uc3QgaWQgPSBkLmlkID8gZC5pZCA6IHRoaXMuaWRDb3VudGVyO1xuICAgICAgZC5pZCA9IGlkO1xuICAgICAgdGhpcy5pZENvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9KTtcblxuICAgIC8vIGVudGVyXG4gICAgY29uc3QgbGlua0VudGVyID0gbGlua1NlbGVjdGlvblxuICAgICAgLmVudGVyKClcbiAgICAgIC8vIC5maWx0ZXIoZCA9PiBkLmRlcHRoID4gMSkgLy8gZG9uJ3QgZHJhdyBsaW5rcyB0byByb290IGVsZW1lbnRcbiAgICAgIC5pbnNlcnQoJ3BhdGgnLCAnZycpXG4gICAgICAuYXR0cignY2xhc3MnLCAndHJlZV9fbGluaycpXG4gICAgICAuYXR0cignZCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgbyA9IHsgeDogdGhpcy5zb3VyY2VDb29yZC54LCB5OiB0aGlzLnNvdXJjZUNvb3JkLnkgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuZGlhZ29uYWwobywgbyk7XG4gICAgICB9KTtcblxuICAgIGxpbmtFbnRlclxuICAgICAgLy8gLnRyYW5zaXRpb24oKVxuICAgICAgLy8gLmR1cmF0aW9uKHRoaXMuY29uZmlnLmR1cmF0aW9uKVxuICAgICAgLmF0dHIoJ2QnLCBkID0+IHRoaXMuY29uc3RydWN0b3IuZGlhZ29uYWwoZCwgZC5wYXJlbnQpKTtcblxuICAgIC8vIGV4aXRcbiAgICBsaW5rU2VsZWN0aW9uXG4gICAgICAuZXhpdCgpXG4gICAgICAudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oNzUwKVxuICAgICAgLmF0dHIoJ2QnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSB7IHk6IHRoaXMuc291cmNlQ29vcmQueSwgeDogdGhpcy5zb3VyY2VDb29yZC54IH07XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmRpYWdvbmFsKG8sIG8pO1xuICAgICAgfSlcbiAgICAgIC5yZW1vdmUoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUcmVlQ2hhcnQ7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/TreeChart.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _TreeChart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TreeChart */ \"./src/TreeChart.js\");\n/* harmony import */ var _CategoryTimeline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CategoryTimeline */ \"./src/CategoryTimeline.js\");\n\n\n\nasync function getData(file) {\n  return fetch(file)\n    .then(res => res.json())\n    .then(dataJson => dataJson);\n}\n\nfunction calculateCategoryCount(data) {\n  let categoryCount = 0;\n  data.registers.forEach(register => register.categories.forEach(category => (categoryCount += 1)));\n  return categoryCount;\n}\n\nfunction categoryTimelineHelper(samplingData, svg, config) {\n  let timelineData = samplingData;\n  const parentsData = timelineData.filter(el => el.parents);\n  const subjectsData = timelineData.filter(el => !el.parents);\n  timelineData = [\n    {\n      type: 'parents',\n      data: parentsData,\n    },\n    {\n      type: 'subjects',\n      data: subjectsData,\n    },\n  ];\n  return new _CategoryTimeline__WEBPACK_IMPORTED_MODULE_1__[\"default\"](timelineData, svg, config);\n}\n\nfunction compareByName(a, b) {\n  if (a.name < b.name) {\n    return -1;\n  } else if (a.name > b.name) {\n    return 1;\n  }\n  return 0;\n}\n\nfunction sortTreeData(data) {\n  data.registers.sort((a, b) => compareByName(a, b));\n  data.registers.forEach(register => register.categories.sort((a, b) => compareByName(a, b)));\n  return data;\n}\n\nasync function drawTimelineTree(\n  filename,\n  filteredRegisters = [],\n  treeConfigMod = {},\n  timelineConfigMod = {},\n) {\n  let data = await getData(`data/${filename}`);\n  const filteredRegisterData = data.registers.filter(register => !filteredRegisters.includes(register.name));\n  data.registers = filteredRegisterData;\n  data = sortTreeData(data);\n  const categoryCount = calculateCategoryCount(data);\n  const treeHeight = categoryCount * 100;\n  // ***** TreeChart *****\n\n  const treeConfig = {\n    width: 450,\n    height: treeHeight,\n    posX: 125,\n    posY: 50,\n    childrenNames: ['registers', 'categories'],\n    animationDuration: 750,\n    nodeSize: 7.5,\n  };\n\n  const svg = d3\n    .select(`main.chart-area>div[data-filename=\"${filename}\"]`)\n    .append('svg')\n    .attr('data-filename', filename)\n    .attr('height', treeHeight + 100)\n    .attr('width', 1050)\n    .attr('class', 'timeline-tree js-timeline-tree');\n\n  const treeChart = new _TreeChart__WEBPACK_IMPORTED_MODULE_0__[\"default\"](data, svg, treeConfig);\n  treeChart.updateNodes();\n  treeChart.updateLinks();\n\n  // ***** Timelines *****\n  console.log(timelineConfigMod.scaleEndDate);\n  const timelineConfig = {\n    width: 250,\n    height: 100,\n    showXAxis: false,\n    showLegend: false,\n    scaleStartDate: timelineConfigMod.scaleStartDate\n      ? timelineConfigMod.scaleStartDate\n      : new Date('1950-01-01'),\n    scaleEndDate: timelineConfigMod.scaleEndDate ? timelineConfigMod.scaleEndDate : new Date(),\n  };\n  treeChart.treeData.children.forEach((registerNode, registerIdx) => {\n    registerNode.children.forEach((categoryNode, categoryIdx) => {\n      let timelineConfigExt = timelineConfig;\n      if (\n        registerIdx === treeChart.treeData.children.length - 1 &&\n        categoryIdx === registerNode.children.length - 1\n      ) {\n        timelineConfigExt = { ...timelineConfig, showXAxis: true, showLegend: true };\n      }\n      const categoryTimeline = categoryTimelineHelper(\n        categoryNode.data.samplings,\n        svg,\n        timelineConfigExt,\n      );\n      // NOTE: the tree structure kind of swaps x and y coords\n      categoryTimeline.moveTo(categoryNode.y + 300, categoryNode.x + 12.5);\n      categoryTimeline.update();\n    });\n  });\n}\n\nfunction removeTimelineTree(filename) {\n  const elToRemove = document.querySelector(`.js-timeline-tree[data-filename=\"${filename}\"]`);\n  if (elToRemove) {\n    elToRemove.remove();\n  }\n}\n\nfunction activateSidebar() {\n  document.querySelectorAll('.js-register-btn').forEach((el) => {\n    el.addEventListener('click', () => {\n      const { filename } = el.dataset;\n      if (![...el.classList].includes('btn--selected')) {\n        el.classList.add('btn--selected');\n        drawTimelineTree(filename);\n        showRegisterSelector(el.parentElement, filename);\n      } else {\n        removeTimelineTree(filename);\n        hideRegisterSelector(el.parentElement);\n        el.classList.remove('btn--selected');\n      }\n    });\n  });\n}\n\nfunction activateRegisterSelector(selectorEl) {\n  const { filename } = selectorEl.dataset;\n\n  selectorEl.querySelectorAll('.js-register-select').forEach((checkboxEl) => {\n    checkboxEl.addEventListener('change', () => {\n      const filterList = getFilterList(filename);\n      removeTimelineTree(filename);\n      drawTimelineTree(filename, filterList);\n    });\n  });\n}\n\nfunction activateYearSelectControls(filename) {\n  const timelineTree = document.querySelector(`.js-timeline-tree-card[data-filename=\"${filename}\"]`);\n  const setYearsBtn = timelineTree.querySelector('.js-set-years-btn');\n  setYearsBtn.addEventListener('click', () => {\n    let startYear = parseInt(timelineTree.querySelector('.js-start-year').value, 10);\n    startYear = !isNaN(startYear) ? startYear : 1950;\n    let endYear = parseInt(timelineTree.querySelector('.js-end-year').value, 10);\n    endYear = !isNaN(endYear) && endYear > startYear ? endYear : new Date().getFullYear();\n\n    startYear = `${startYear}-01-01`;\n    endYear = `${endYear}-12-31`;\n    console.log(endYear);\n    const timelineConfigMod = {\n      scaleStartDate: new Date(startYear),\n      scaleEndDate: new Date(endYear),\n    };\n    const filteredRegisters = getFilterList(filename);\n    removeTimelineTree(filename);\n    drawTimelineTree(filename, filteredRegisters, {}, timelineConfigMod);\n  });\n}\n\nfunction getFilterList(filename) {\n  const selectorEl = document.querySelector(`.js-register-list[data-filename=\"${filename}\"]`);\n  const filterList = [...selectorEl.querySelectorAll('.js-register-select')]\n    .filter(checkbox => !checkbox.checked)\n    .map(checkbox => checkbox.dataset.identifier.split('/')[1]);\n\n  return filterList;\n}\n\nfunction createSidebar(filenames) {\n  filenames\n    .map(name => name.split('.')[0])\n    .sort()\n    .forEach((name) => {\n      const navItem = document.createElement('li');\n      navItem.classList.add('nav__item');\n      navItem.innerHTML = `<button class=\"btn js-register-btn\" data-filename=\"${name}.json\">${name}</button>`;\n      document.querySelector('.js-nav-list').appendChild(navItem);\n    });\n}\n\nasync function createRegisterSelector(navItem, filename) {\n  let data = await getData(`data/${filename}`);\n  data = sortTreeData(data);\n  const registerList = document.createElement('ul');\n  registerList.classList.add('register-selector', 'js-register-list');\n  registerList.dataset.filename = filename;\n  data.registers.forEach((register) => {\n    const identifier = `${filename}/${register.name}`;\n    const listItem = document.createElement('li');\n    listItem.classList.add('register__item');\n    listItem.innerHTML = `<input class=\"js-register-select\" type=\"checkbox\" id=\"${identifier}\" \n    data-identifier=\"${identifier}\" checked/>\n    <label for=\"${identifier}\">${register.name}</label>`;\n    registerList.appendChild(listItem);\n  });\n  navItem.appendChild(registerList);\n  activateRegisterSelector(registerList);\n}\n\nfunction createYearSelector(startYear, endYear, optionText = '--year--') {\n  const select = document.createElement('select');\n  select.classList.add('year-selector');\n  const firstOption = document.createElement('option');\n  firstOption.value = '';\n  firstOption.textContent = optionText;\n  select.appendChild(firstOption);\n  for (let year = startYear; year <= endYear; year += 1) {\n    const option = document.createElement('option');\n    option.value = year;\n    option.textContent = year;\n    select.appendChild(option);\n  }\n\n  return select;\n}\n\nfunction createTimelineTreeCards(filenames) {\n  filenames.forEach((filename) => {\n    const placeholder = document.createElement('div');\n    placeholder.classList.add('timeline-tree-wrapper', 'card', 'js-timeline-tree-card');\n    placeholder.dataset.filename = filename;\n    const cardHeader = document.createElement('div');\n    cardHeader.classList.add('card__header');\n    cardHeader.innerHTML = `\n    <h2 class=\"title card__title\">${filename.slice(0, -5)}</h2>\n    <div class=\"year-control card__year-control js-year-control\">\n      <label class=\"year-form__label\">Timeline years: </label>\n    </div>`;\n    const startYearSelector = createYearSelector(1900, new Date().getFullYear(), '--start year--');\n    startYearSelector.classList.add('js-start-year');\n    const endYearSelector = createYearSelector(1900, new Date().getFullYear(), '--end year--');\n    endYearSelector.classList.add('js-end-year');\n    const setYearsBtn = document.createElement('button');\n    setYearsBtn.classList.add('js-set-years-btn');\n    setYearsBtn.dataset.filename = filename;\n    setYearsBtn.textContent = 'Set';\n    const yearForm = cardHeader.querySelector('.js-year-control');\n    yearForm.appendChild(startYearSelector);\n    yearForm.appendChild(document.createTextNode(' — '));\n    yearForm.appendChild(endYearSelector);\n    yearForm.appendChild(setYearsBtn);\n\n    placeholder.appendChild(cardHeader);\n    document.querySelector('main.chart-area').appendChild(placeholder);\n    activateYearSelectControls(filename);\n  });\n}\n\nasync function showRegisterSelector(navItem, filename) {\n  const registerSelector = navItem.querySelector('.register-selector');\n  if (registerSelector === null) {\n    createRegisterSelector(navItem, filename);\n  } else {\n    registerSelector.classList.remove('vanish');\n  }\n}\n\nfunction hideRegisterSelector(navItem) {\n  navItem.querySelector('.register-selector').classList.add('vanish');\n}\n\nasync function main() {\n  const filenames = await getData('data/filenames.json');\n  filenames.sort();\n  createTimelineTreeCards(filenames);\n  createSidebar(filenames);\n  activateSidebar();\n\n  const toggleBtn = document.querySelector('.js-toggle-menu');\n  toggleBtn.addEventListener('click', () => {\n    document.querySelector('.js-nav-card').classList.toggle('nav--closed');\n    toggleBtn.classList.toggle('nav__toggle-btn--rotate');\n  });\n\n  document\n    .querySelector('.js-register-btn[data-filename=\"National Institute for Health and Welfare.json\"]')\n    .click();\n}\n\nmain();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4QjtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0EsZ0ZBQWdGLFNBQVM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSx1RkFBdUYsU0FBUztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFVBQVU7QUFDN0IsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsR0FBRztBQUNIOztBQUVBO0FBQ0EsZ0ZBQWdGLFNBQVM7QUFDekY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsS0FBSyxTQUFTLEtBQUs7QUFDbkc7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVMsR0FBRyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQSxrRkFBa0YsV0FBVztBQUM3Rix1QkFBdUIsV0FBVztBQUNsQyxrQkFBa0IsV0FBVyxJQUFJLGNBQWM7QUFDL0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUcmVlQ2hhcnQgZnJvbSAnLi9UcmVlQ2hhcnQnO1xuaW1wb3J0IENhdGVnb3J5VGltZWxpbmUgZnJvbSAnLi9DYXRlZ29yeVRpbWVsaW5lJztcblxuYXN5bmMgZnVuY3Rpb24gZ2V0RGF0YShmaWxlKSB7XG4gIHJldHVybiBmZXRjaChmaWxlKVxuICAgIC50aGVuKHJlcyA9PiByZXMuanNvbigpKVxuICAgIC50aGVuKGRhdGFKc29uID0+IGRhdGFKc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQ2F0ZWdvcnlDb3VudChkYXRhKSB7XG4gIGxldCBjYXRlZ29yeUNvdW50ID0gMDtcbiAgZGF0YS5yZWdpc3RlcnMuZm9yRWFjaChyZWdpc3RlciA9PiByZWdpc3Rlci5jYXRlZ29yaWVzLmZvckVhY2goY2F0ZWdvcnkgPT4gKGNhdGVnb3J5Q291bnQgKz0gMSkpKTtcbiAgcmV0dXJuIGNhdGVnb3J5Q291bnQ7XG59XG5cbmZ1bmN0aW9uIGNhdGVnb3J5VGltZWxpbmVIZWxwZXIoc2FtcGxpbmdEYXRhLCBzdmcsIGNvbmZpZykge1xuICBsZXQgdGltZWxpbmVEYXRhID0gc2FtcGxpbmdEYXRhO1xuICBjb25zdCBwYXJlbnRzRGF0YSA9IHRpbWVsaW5lRGF0YS5maWx0ZXIoZWwgPT4gZWwucGFyZW50cyk7XG4gIGNvbnN0IHN1YmplY3RzRGF0YSA9IHRpbWVsaW5lRGF0YS5maWx0ZXIoZWwgPT4gIWVsLnBhcmVudHMpO1xuICB0aW1lbGluZURhdGEgPSBbXG4gICAge1xuICAgICAgdHlwZTogJ3BhcmVudHMnLFxuICAgICAgZGF0YTogcGFyZW50c0RhdGEsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiAnc3ViamVjdHMnLFxuICAgICAgZGF0YTogc3ViamVjdHNEYXRhLFxuICAgIH0sXG4gIF07XG4gIHJldHVybiBuZXcgQ2F0ZWdvcnlUaW1lbGluZSh0aW1lbGluZURhdGEsIHN2ZywgY29uZmlnKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUJ5TmFtZShhLCBiKSB7XG4gIGlmIChhLm5hbWUgPCBiLm5hbWUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYS5uYW1lID4gYi5uYW1lKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIHNvcnRUcmVlRGF0YShkYXRhKSB7XG4gIGRhdGEucmVnaXN0ZXJzLnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCeU5hbWUoYSwgYikpO1xuICBkYXRhLnJlZ2lzdGVycy5mb3JFYWNoKHJlZ2lzdGVyID0+IHJlZ2lzdGVyLmNhdGVnb3JpZXMuc29ydCgoYSwgYikgPT4gY29tcGFyZUJ5TmFtZShhLCBiKSkpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZHJhd1RpbWVsaW5lVHJlZShcbiAgZmlsZW5hbWUsXG4gIGZpbHRlcmVkUmVnaXN0ZXJzID0gW10sXG4gIHRyZWVDb25maWdNb2QgPSB7fSxcbiAgdGltZWxpbmVDb25maWdNb2QgPSB7fSxcbikge1xuICBsZXQgZGF0YSA9IGF3YWl0IGdldERhdGEoYGRhdGEvJHtmaWxlbmFtZX1gKTtcbiAgY29uc3QgZmlsdGVyZWRSZWdpc3RlckRhdGEgPSBkYXRhLnJlZ2lzdGVycy5maWx0ZXIocmVnaXN0ZXIgPT4gIWZpbHRlcmVkUmVnaXN0ZXJzLmluY2x1ZGVzKHJlZ2lzdGVyLm5hbWUpKTtcbiAgZGF0YS5yZWdpc3RlcnMgPSBmaWx0ZXJlZFJlZ2lzdGVyRGF0YTtcbiAgZGF0YSA9IHNvcnRUcmVlRGF0YShkYXRhKTtcbiAgY29uc3QgY2F0ZWdvcnlDb3VudCA9IGNhbGN1bGF0ZUNhdGVnb3J5Q291bnQoZGF0YSk7XG4gIGNvbnN0IHRyZWVIZWlnaHQgPSBjYXRlZ29yeUNvdW50ICogMTAwO1xuICAvLyAqKioqKiBUcmVlQ2hhcnQgKioqKipcblxuICBjb25zdCB0cmVlQ29uZmlnID0ge1xuICAgIHdpZHRoOiA0NTAsXG4gICAgaGVpZ2h0OiB0cmVlSGVpZ2h0LFxuICAgIHBvc1g6IDEyNSxcbiAgICBwb3NZOiA1MCxcbiAgICBjaGlsZHJlbk5hbWVzOiBbJ3JlZ2lzdGVycycsICdjYXRlZ29yaWVzJ10sXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDc1MCxcbiAgICBub2RlU2l6ZTogNy41LFxuICB9O1xuXG4gIGNvbnN0IHN2ZyA9IGQzXG4gICAgLnNlbGVjdChgbWFpbi5jaGFydC1hcmVhPmRpdltkYXRhLWZpbGVuYW1lPVwiJHtmaWxlbmFtZX1cIl1gKVxuICAgIC5hcHBlbmQoJ3N2ZycpXG4gICAgLmF0dHIoJ2RhdGEtZmlsZW5hbWUnLCBmaWxlbmFtZSlcbiAgICAuYXR0cignaGVpZ2h0JywgdHJlZUhlaWdodCArIDEwMClcbiAgICAuYXR0cignd2lkdGgnLCAxMDUwKVxuICAgIC5hdHRyKCdjbGFzcycsICd0aW1lbGluZS10cmVlIGpzLXRpbWVsaW5lLXRyZWUnKTtcblxuICBjb25zdCB0cmVlQ2hhcnQgPSBuZXcgVHJlZUNoYXJ0KGRhdGEsIHN2ZywgdHJlZUNvbmZpZyk7XG4gIHRyZWVDaGFydC51cGRhdGVOb2RlcygpO1xuICB0cmVlQ2hhcnQudXBkYXRlTGlua3MoKTtcblxuICAvLyAqKioqKiBUaW1lbGluZXMgKioqKipcbiAgY29uc29sZS5sb2codGltZWxpbmVDb25maWdNb2Quc2NhbGVFbmREYXRlKTtcbiAgY29uc3QgdGltZWxpbmVDb25maWcgPSB7XG4gICAgd2lkdGg6IDI1MCxcbiAgICBoZWlnaHQ6IDEwMCxcbiAgICBzaG93WEF4aXM6IGZhbHNlLFxuICAgIHNob3dMZWdlbmQ6IGZhbHNlLFxuICAgIHNjYWxlU3RhcnREYXRlOiB0aW1lbGluZUNvbmZpZ01vZC5zY2FsZVN0YXJ0RGF0ZVxuICAgICAgPyB0aW1lbGluZUNvbmZpZ01vZC5zY2FsZVN0YXJ0RGF0ZVxuICAgICAgOiBuZXcgRGF0ZSgnMTk1MC0wMS0wMScpLFxuICAgIHNjYWxlRW5kRGF0ZTogdGltZWxpbmVDb25maWdNb2Quc2NhbGVFbmREYXRlID8gdGltZWxpbmVDb25maWdNb2Quc2NhbGVFbmREYXRlIDogbmV3IERhdGUoKSxcbiAgfTtcbiAgdHJlZUNoYXJ0LnRyZWVEYXRhLmNoaWxkcmVuLmZvckVhY2goKHJlZ2lzdGVyTm9kZSwgcmVnaXN0ZXJJZHgpID0+IHtcbiAgICByZWdpc3Rlck5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2F0ZWdvcnlOb2RlLCBjYXRlZ29yeUlkeCkgPT4ge1xuICAgICAgbGV0IHRpbWVsaW5lQ29uZmlnRXh0ID0gdGltZWxpbmVDb25maWc7XG4gICAgICBpZiAoXG4gICAgICAgIHJlZ2lzdGVySWR4ID09PSB0cmVlQ2hhcnQudHJlZURhdGEuY2hpbGRyZW4ubGVuZ3RoIC0gMSAmJlxuICAgICAgICBjYXRlZ29yeUlkeCA9PT0gcmVnaXN0ZXJOb2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFcbiAgICAgICkge1xuICAgICAgICB0aW1lbGluZUNvbmZpZ0V4dCA9IHsgLi4udGltZWxpbmVDb25maWcsIHNob3dYQXhpczogdHJ1ZSwgc2hvd0xlZ2VuZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY2F0ZWdvcnlUaW1lbGluZSA9IGNhdGVnb3J5VGltZWxpbmVIZWxwZXIoXG4gICAgICAgIGNhdGVnb3J5Tm9kZS5kYXRhLnNhbXBsaW5ncyxcbiAgICAgICAgc3ZnLFxuICAgICAgICB0aW1lbGluZUNvbmZpZ0V4dCxcbiAgICAgICk7XG4gICAgICAvLyBOT1RFOiB0aGUgdHJlZSBzdHJ1Y3R1cmUga2luZCBvZiBzd2FwcyB4IGFuZCB5IGNvb3Jkc1xuICAgICAgY2F0ZWdvcnlUaW1lbGluZS5tb3ZlVG8oY2F0ZWdvcnlOb2RlLnkgKyAzMDAsIGNhdGVnb3J5Tm9kZS54ICsgMTIuNSk7XG4gICAgICBjYXRlZ29yeVRpbWVsaW5lLnVwZGF0ZSgpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlVGltZWxpbmVUcmVlKGZpbGVuYW1lKSB7XG4gIGNvbnN0IGVsVG9SZW1vdmUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAuanMtdGltZWxpbmUtdHJlZVtkYXRhLWZpbGVuYW1lPVwiJHtmaWxlbmFtZX1cIl1gKTtcbiAgaWYgKGVsVG9SZW1vdmUpIHtcbiAgICBlbFRvUmVtb3ZlLnJlbW92ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlU2lkZWJhcigpIHtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmpzLXJlZ2lzdGVyLWJ0bicpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IGZpbGVuYW1lIH0gPSBlbC5kYXRhc2V0O1xuICAgICAgaWYgKCFbLi4uZWwuY2xhc3NMaXN0XS5pbmNsdWRlcygnYnRuLS1zZWxlY3RlZCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2J0bi0tc2VsZWN0ZWQnKTtcbiAgICAgICAgZHJhd1RpbWVsaW5lVHJlZShmaWxlbmFtZSk7XG4gICAgICAgIHNob3dSZWdpc3RlclNlbGVjdG9yKGVsLnBhcmVudEVsZW1lbnQsIGZpbGVuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZVRpbWVsaW5lVHJlZShmaWxlbmFtZSk7XG4gICAgICAgIGhpZGVSZWdpc3RlclNlbGVjdG9yKGVsLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdidG4tLXNlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZVJlZ2lzdGVyU2VsZWN0b3Ioc2VsZWN0b3JFbCkge1xuICBjb25zdCB7IGZpbGVuYW1lIH0gPSBzZWxlY3RvckVsLmRhdGFzZXQ7XG5cbiAgc2VsZWN0b3JFbC5xdWVyeVNlbGVjdG9yQWxsKCcuanMtcmVnaXN0ZXItc2VsZWN0JykuZm9yRWFjaCgoY2hlY2tib3hFbCkgPT4ge1xuICAgIGNoZWNrYm94RWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgY29uc3QgZmlsdGVyTGlzdCA9IGdldEZpbHRlckxpc3QoZmlsZW5hbWUpO1xuICAgICAgcmVtb3ZlVGltZWxpbmVUcmVlKGZpbGVuYW1lKTtcbiAgICAgIGRyYXdUaW1lbGluZVRyZWUoZmlsZW5hbWUsIGZpbHRlckxpc3QpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVZZWFyU2VsZWN0Q29udHJvbHMoZmlsZW5hbWUpIHtcbiAgY29uc3QgdGltZWxpbmVUcmVlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLmpzLXRpbWVsaW5lLXRyZWUtY2FyZFtkYXRhLWZpbGVuYW1lPVwiJHtmaWxlbmFtZX1cIl1gKTtcbiAgY29uc3Qgc2V0WWVhcnNCdG4gPSB0aW1lbGluZVRyZWUucXVlcnlTZWxlY3RvcignLmpzLXNldC15ZWFycy1idG4nKTtcbiAgc2V0WWVhcnNCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgbGV0IHN0YXJ0WWVhciA9IHBhcnNlSW50KHRpbWVsaW5lVHJlZS5xdWVyeVNlbGVjdG9yKCcuanMtc3RhcnQteWVhcicpLnZhbHVlLCAxMCk7XG4gICAgc3RhcnRZZWFyID0gIWlzTmFOKHN0YXJ0WWVhcikgPyBzdGFydFllYXIgOiAxOTUwO1xuICAgIGxldCBlbmRZZWFyID0gcGFyc2VJbnQodGltZWxpbmVUcmVlLnF1ZXJ5U2VsZWN0b3IoJy5qcy1lbmQteWVhcicpLnZhbHVlLCAxMCk7XG4gICAgZW5kWWVhciA9ICFpc05hTihlbmRZZWFyKSAmJiBlbmRZZWFyID4gc3RhcnRZZWFyID8gZW5kWWVhciA6IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcblxuICAgIHN0YXJ0WWVhciA9IGAke3N0YXJ0WWVhcn0tMDEtMDFgO1xuICAgIGVuZFllYXIgPSBgJHtlbmRZZWFyfS0xMi0zMWA7XG4gICAgY29uc29sZS5sb2coZW5kWWVhcik7XG4gICAgY29uc3QgdGltZWxpbmVDb25maWdNb2QgPSB7XG4gICAgICBzY2FsZVN0YXJ0RGF0ZTogbmV3IERhdGUoc3RhcnRZZWFyKSxcbiAgICAgIHNjYWxlRW5kRGF0ZTogbmV3IERhdGUoZW5kWWVhciksXG4gICAgfTtcbiAgICBjb25zdCBmaWx0ZXJlZFJlZ2lzdGVycyA9IGdldEZpbHRlckxpc3QoZmlsZW5hbWUpO1xuICAgIHJlbW92ZVRpbWVsaW5lVHJlZShmaWxlbmFtZSk7XG4gICAgZHJhd1RpbWVsaW5lVHJlZShmaWxlbmFtZSwgZmlsdGVyZWRSZWdpc3RlcnMsIHt9LCB0aW1lbGluZUNvbmZpZ01vZCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRGaWx0ZXJMaXN0KGZpbGVuYW1lKSB7XG4gIGNvbnN0IHNlbGVjdG9yRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAuanMtcmVnaXN0ZXItbGlzdFtkYXRhLWZpbGVuYW1lPVwiJHtmaWxlbmFtZX1cIl1gKTtcbiAgY29uc3QgZmlsdGVyTGlzdCA9IFsuLi5zZWxlY3RvckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5qcy1yZWdpc3Rlci1zZWxlY3QnKV1cbiAgICAuZmlsdGVyKGNoZWNrYm94ID0+ICFjaGVja2JveC5jaGVja2VkKVxuICAgIC5tYXAoY2hlY2tib3ggPT4gY2hlY2tib3guZGF0YXNldC5pZGVudGlmaWVyLnNwbGl0KCcvJylbMV0pO1xuXG4gIHJldHVybiBmaWx0ZXJMaXN0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTaWRlYmFyKGZpbGVuYW1lcykge1xuICBmaWxlbmFtZXNcbiAgICAubWFwKG5hbWUgPT4gbmFtZS5zcGxpdCgnLicpWzBdKVxuICAgIC5zb3J0KClcbiAgICAuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgY29uc3QgbmF2SXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICBuYXZJdGVtLmNsYXNzTGlzdC5hZGQoJ25hdl9faXRlbScpO1xuICAgICAgbmF2SXRlbS5pbm5lckhUTUwgPSBgPGJ1dHRvbiBjbGFzcz1cImJ0biBqcy1yZWdpc3Rlci1idG5cIiBkYXRhLWZpbGVuYW1lPVwiJHtuYW1lfS5qc29uXCI+JHtuYW1lfTwvYnV0dG9uPmA7XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuanMtbmF2LWxpc3QnKS5hcHBlbmRDaGlsZChuYXZJdGVtKTtcbiAgICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlUmVnaXN0ZXJTZWxlY3RvcihuYXZJdGVtLCBmaWxlbmFtZSkge1xuICBsZXQgZGF0YSA9IGF3YWl0IGdldERhdGEoYGRhdGEvJHtmaWxlbmFtZX1gKTtcbiAgZGF0YSA9IHNvcnRUcmVlRGF0YShkYXRhKTtcbiAgY29uc3QgcmVnaXN0ZXJMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgcmVnaXN0ZXJMaXN0LmNsYXNzTGlzdC5hZGQoJ3JlZ2lzdGVyLXNlbGVjdG9yJywgJ2pzLXJlZ2lzdGVyLWxpc3QnKTtcbiAgcmVnaXN0ZXJMaXN0LmRhdGFzZXQuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgZGF0YS5yZWdpc3RlcnMuZm9yRWFjaCgocmVnaXN0ZXIpID0+IHtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gYCR7ZmlsZW5hbWV9LyR7cmVnaXN0ZXIubmFtZX1gO1xuICAgIGNvbnN0IGxpc3RJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICBsaXN0SXRlbS5jbGFzc0xpc3QuYWRkKCdyZWdpc3Rlcl9faXRlbScpO1xuICAgIGxpc3RJdGVtLmlubmVySFRNTCA9IGA8aW5wdXQgY2xhc3M9XCJqcy1yZWdpc3Rlci1zZWxlY3RcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cIiR7aWRlbnRpZmllcn1cIiBcbiAgICBkYXRhLWlkZW50aWZpZXI9XCIke2lkZW50aWZpZXJ9XCIgY2hlY2tlZC8+XG4gICAgPGxhYmVsIGZvcj1cIiR7aWRlbnRpZmllcn1cIj4ke3JlZ2lzdGVyLm5hbWV9PC9sYWJlbD5gO1xuICAgIHJlZ2lzdGVyTGlzdC5hcHBlbmRDaGlsZChsaXN0SXRlbSk7XG4gIH0pO1xuICBuYXZJdGVtLmFwcGVuZENoaWxkKHJlZ2lzdGVyTGlzdCk7XG4gIGFjdGl2YXRlUmVnaXN0ZXJTZWxlY3RvcihyZWdpc3Rlckxpc3QpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVZZWFyU2VsZWN0b3Ioc3RhcnRZZWFyLCBlbmRZZWFyLCBvcHRpb25UZXh0ID0gJy0teWVhci0tJykge1xuICBjb25zdCBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgc2VsZWN0LmNsYXNzTGlzdC5hZGQoJ3llYXItc2VsZWN0b3InKTtcbiAgY29uc3QgZmlyc3RPcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgZmlyc3RPcHRpb24udmFsdWUgPSAnJztcbiAgZmlyc3RPcHRpb24udGV4dENvbnRlbnQgPSBvcHRpb25UZXh0O1xuICBzZWxlY3QuYXBwZW5kQ2hpbGQoZmlyc3RPcHRpb24pO1xuICBmb3IgKGxldCB5ZWFyID0gc3RhcnRZZWFyOyB5ZWFyIDw9IGVuZFllYXI7IHllYXIgKz0gMSkge1xuICAgIGNvbnN0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgIG9wdGlvbi52YWx1ZSA9IHllYXI7XG4gICAgb3B0aW9uLnRleHRDb250ZW50ID0geWVhcjtcbiAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Q7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVsaW5lVHJlZUNhcmRzKGZpbGVuYW1lcykge1xuICBmaWxlbmFtZXMuZm9yRWFjaCgoZmlsZW5hbWUpID0+IHtcbiAgICBjb25zdCBwbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHBsYWNlaG9sZGVyLmNsYXNzTGlzdC5hZGQoJ3RpbWVsaW5lLXRyZWUtd3JhcHBlcicsICdjYXJkJywgJ2pzLXRpbWVsaW5lLXRyZWUtY2FyZCcpO1xuICAgIHBsYWNlaG9sZGVyLmRhdGFzZXQuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICBjb25zdCBjYXJkSGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY2FyZEhlYWRlci5jbGFzc0xpc3QuYWRkKCdjYXJkX19oZWFkZXInKTtcbiAgICBjYXJkSGVhZGVyLmlubmVySFRNTCA9IGBcbiAgICA8aDIgY2xhc3M9XCJ0aXRsZSBjYXJkX190aXRsZVwiPiR7ZmlsZW5hbWUuc2xpY2UoMCwgLTUpfTwvaDI+XG4gICAgPGRpdiBjbGFzcz1cInllYXItY29udHJvbCBjYXJkX195ZWFyLWNvbnRyb2wganMteWVhci1jb250cm9sXCI+XG4gICAgICA8bGFiZWwgY2xhc3M9XCJ5ZWFyLWZvcm1fX2xhYmVsXCI+VGltZWxpbmUgeWVhcnM6IDwvbGFiZWw+XG4gICAgPC9kaXY+YDtcbiAgICBjb25zdCBzdGFydFllYXJTZWxlY3RvciA9IGNyZWF0ZVllYXJTZWxlY3RvcigxOTAwLCBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksICctLXN0YXJ0IHllYXItLScpO1xuICAgIHN0YXJ0WWVhclNlbGVjdG9yLmNsYXNzTGlzdC5hZGQoJ2pzLXN0YXJ0LXllYXInKTtcbiAgICBjb25zdCBlbmRZZWFyU2VsZWN0b3IgPSBjcmVhdGVZZWFyU2VsZWN0b3IoMTkwMCwgbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLCAnLS1lbmQgeWVhci0tJyk7XG4gICAgZW5kWWVhclNlbGVjdG9yLmNsYXNzTGlzdC5hZGQoJ2pzLWVuZC15ZWFyJyk7XG4gICAgY29uc3Qgc2V0WWVhcnNCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBzZXRZZWFyc0J0bi5jbGFzc0xpc3QuYWRkKCdqcy1zZXQteWVhcnMtYnRuJyk7XG4gICAgc2V0WWVhcnNCdG4uZGF0YXNldC5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgIHNldFllYXJzQnRuLnRleHRDb250ZW50ID0gJ1NldCc7XG4gICAgY29uc3QgeWVhckZvcm0gPSBjYXJkSGVhZGVyLnF1ZXJ5U2VsZWN0b3IoJy5qcy15ZWFyLWNvbnRyb2wnKTtcbiAgICB5ZWFyRm9ybS5hcHBlbmRDaGlsZChzdGFydFllYXJTZWxlY3Rvcik7XG4gICAgeWVhckZvcm0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyDigJQgJykpO1xuICAgIHllYXJGb3JtLmFwcGVuZENoaWxkKGVuZFllYXJTZWxlY3Rvcik7XG4gICAgeWVhckZvcm0uYXBwZW5kQ2hpbGQoc2V0WWVhcnNCdG4pO1xuXG4gICAgcGxhY2Vob2xkZXIuYXBwZW5kQ2hpbGQoY2FyZEhlYWRlcik7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWFpbi5jaGFydC1hcmVhJykuYXBwZW5kQ2hpbGQocGxhY2Vob2xkZXIpO1xuICAgIGFjdGl2YXRlWWVhclNlbGVjdENvbnRyb2xzKGZpbGVuYW1lKTtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNob3dSZWdpc3RlclNlbGVjdG9yKG5hdkl0ZW0sIGZpbGVuYW1lKSB7XG4gIGNvbnN0IHJlZ2lzdGVyU2VsZWN0b3IgPSBuYXZJdGVtLnF1ZXJ5U2VsZWN0b3IoJy5yZWdpc3Rlci1zZWxlY3RvcicpO1xuICBpZiAocmVnaXN0ZXJTZWxlY3RvciA9PT0gbnVsbCkge1xuICAgIGNyZWF0ZVJlZ2lzdGVyU2VsZWN0b3IobmF2SXRlbSwgZmlsZW5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHJlZ2lzdGVyU2VsZWN0b3IuY2xhc3NMaXN0LnJlbW92ZSgndmFuaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGlkZVJlZ2lzdGVyU2VsZWN0b3IobmF2SXRlbSkge1xuICBuYXZJdGVtLnF1ZXJ5U2VsZWN0b3IoJy5yZWdpc3Rlci1zZWxlY3RvcicpLmNsYXNzTGlzdC5hZGQoJ3ZhbmlzaCcpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBtYWluKCkge1xuICBjb25zdCBmaWxlbmFtZXMgPSBhd2FpdCBnZXREYXRhKCdkYXRhL2ZpbGVuYW1lcy5qc29uJyk7XG4gIGZpbGVuYW1lcy5zb3J0KCk7XG4gIGNyZWF0ZVRpbWVsaW5lVHJlZUNhcmRzKGZpbGVuYW1lcyk7XG4gIGNyZWF0ZVNpZGViYXIoZmlsZW5hbWVzKTtcbiAgYWN0aXZhdGVTaWRlYmFyKCk7XG5cbiAgY29uc3QgdG9nZ2xlQnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmpzLXRvZ2dsZS1tZW51Jyk7XG4gIHRvZ2dsZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuanMtbmF2LWNhcmQnKS5jbGFzc0xpc3QudG9nZ2xlKCduYXYtLWNsb3NlZCcpO1xuICAgIHRvZ2dsZUJ0bi5jbGFzc0xpc3QudG9nZ2xlKCduYXZfX3RvZ2dsZS1idG4tLXJvdGF0ZScpO1xuICB9KTtcblxuICBkb2N1bWVudFxuICAgIC5xdWVyeVNlbGVjdG9yKCcuanMtcmVnaXN0ZXItYnRuW2RhdGEtZmlsZW5hbWU9XCJOYXRpb25hbCBJbnN0aXR1dGUgZm9yIEhlYWx0aCBhbmQgV2VsZmFyZS5qc29uXCJdJylcbiAgICAuY2xpY2soKTtcbn1cblxubWFpbigpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/index.js */"./src/index.js");


/***/ })

/******/ });